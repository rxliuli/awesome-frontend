(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{419:function(_,v,t){"use strict";t.r(v);var a=t(44),r=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#场景"}},[_._v("#")]),_._v(" 场景")]),_._v(" "),t("blockquote",[t("p",[_._v("之前吾辈也在 SF 上询问过 "),t("a",{attrs:{href:"https://segmentfault.com/q/1010000021851252",target:"_blank",rel:"noopener noreferrer"}},[_._v("类似的问题"),t("OutboundLink")],1),_._v("。")])]),_._v(" "),t("p",[_._v("目前在实际业务中遇到了两种情况")]),_._v(" "),t("ol",[t("li",[_._v("程序的功能在分发给不同组织使用的时候有所差异，即不同的组织都会存在一些定制化的功能。\n最常见的差异例如\n"),t("ul",[t("li",[_._v("表单的字段存在差异")]),_._v(" "),t("li",[_._v("列表展示的字段与相关操作有所不同")])])]),_._v(" "),t("li",[_._v("组件内的代码在某个权限下才会执行，但是又依赖于组件内的一些状态，如何将这些代码分割到不同的地方（例如不同的文件）便于之后的维护。\n"),t("ul",[t("li",[_._v("一些按钮在指定权限下存在")]),_._v(" "),t("li",[_._v("一些数据在指定权限下展示")])])])]),_._v(" "),t("h2",{attrs:{id:"方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方案"}},[_._v("#")]),_._v(" 方案")]),_._v(" "),t("ul",[t("li",[_._v("使用动态配置渲染不同的页面(可序列化的配置)")]),_._v(" "),t("li",[_._v("根据状态匹配不同的动态组件")]),_._v(" "),t("li",[_._v("使用 hooks 封装不同的逻辑")]),_._v(" "),t("li",[_._v("使用状态图控制状态和逻辑")])]),_._v(" "),t("h2",{attrs:{id:"实际调研结果"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实际调研结果"}},[_._v("#")]),_._v(" 实际调研结果")]),_._v(" "),t("h3",{attrs:{id:"使用动态配置渲染不同的页面"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用动态配置渲染不同的页面"}},[_._v("#")]),_._v(" 使用动态配置渲染不同的页面")]),_._v(" "),t("p",[_._v("实际上，之前有看过吾辈写的 "),t("a",{attrs:{href:"/p/c55a6470683e498f92ba05d7ff710b3a"}},[_._v("react 通用列表组件封装")]),_._v(" 就知道，实际上列表已经被配置化了，可以使用配置的形式去渲染一个完整的列表页面，因此可以根据不同的组织使用不同的配置就好了。但是，事实上并没有这么简单，因为就算是简单的列表，也仍然包含"),t("strong",[_._v("上下文")]),_._v("，而这，正是配置不能拿到的内容。")]),_._v(" "),t("p",[_._v("上下文主要包括")]),_._v(" "),t("ul",[t("li",[_._v("需要异步请求的数据，例如下拉框的选择项")]),_._v(" "),t("li",[_._v("需要从路由上获取的数据，例如搜索条件")]),_._v(" "),t("li",[_._v("需要对页面内的其它组件进行操作时，例如点击按钮有个新增列表项的弹窗")])]),_._v(" "),t("p",[_._v("可以有几种解决方案")]),_._v(" "),t("ul",[t("li",[_._v("通过函数，而不是单纯的配置，这样，可以通过参数解决一些上下文的依赖情况")]),_._v(" "),t("li",[_._v("通过函数且异步，可以解决 api 请求时，此时的 api 必定是可以用的，但是会依赖于 api。")])]),_._v(" "),t("p",[_._v("但这仍然会带来问题")]),_._v(" "),t("ul",[t("li",[_._v("数据不再纯粹，无法序列化。")]),_._v(" "),t("li",[_._v("不同配置依赖的数据可能不同，需要配置自己去解决，那么如果这样想的话，那么配置就需要自行获取数据，而不是外部传递数据了")]),_._v(" "),t("li",[_._v("仍然无法使用"),t("strong",[_._v("状态")])]),_._v(" "),t("li",[_._v("最重要的是，使用函数之后变得不再像是"),t("strong",[_._v("配置")]),_._v("了")])]),_._v(" "),t("h3",{attrs:{id:"根据状态匹配不同的动态组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#根据状态匹配不同的动态组件"}},[_._v("#")]),_._v(" 根据状态匹配不同的动态组件")]),_._v(" "),t("ul",[t("li",[_._v("配置更为灵活，能够获取到组件的上下文")]),_._v(" "),t("li",[_._v("接口请求也没有问题")]),_._v(" "),t("li",[_._v("对不同配置，可以自行对数据进行处理")])]),_._v(" "),t("p",[_._v("问题")]),_._v(" "),t("ul",[t("li",[_._v("无法如同纯数据配置那样，复用逻辑这么彻底，但是也可以通过 hooks 解决。")]),_._v(" "),t("li",[_._v("UI 复用问题\n先使用组件的方式编写一下，看具体结果如何")]),_._v(" "),t("li",[_._v("无法序列化也意味着无法放到后端，甚至意味着很难做动态加载")])]),_._v(" "),t("p",[_._v("使用")]),_._v(" "),t("ul",[t("li",[_._v("使用一个 wrapper 组件来讲 UI 和通用逻辑给包裹进去")]),_._v(" "),t("li",[_._v("使用另外一套组件去区分不同租户的配置（因为是在组件内部写配置，所以该配置可以灵活的使用任意接口，组件上下文可能还不太行）也就是用多个组件来解决这个问题。")])]),_._v(" "),t("p",[_._v("可以再尝试一下有没有解决方案。")]),_._v(" "),t("h3",{attrs:{id:"使用-hooks-封装不同的代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用-hooks-封装不同的代码"}},[_._v("#")]),_._v(" 使用 hooks 封装不同的代码")]),_._v(" "),t("ul",[t("li",[_._v("相比于处理 "),t("strong",[_._v("是哪一个")]),_._v("，更适合处理 "),t("strong",[_._v("有或没有")]),_._v(" 的代码分割")]),_._v(" "),t("li",[_._v("能够使用 react 的状态")])]),_._v(" "),t("p",[_._v("问题")]),_._v(" "),t("ul",[t("li",[_._v("使用 hooks 必须放在函数组件最顶层，导致本质上无法 "),t("code",[_._v("lazy")]),_._v(" 加载。参考："),t("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-rules.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("Hook 规则"),t("OutboundLink")],1)]),_._v(" "),t("li",[_._v("使用 hooks 同样难以序列化存储到后端")])]),_._v(" "),t("h3",{attrs:{id:"使用状态图控制状态和逻辑"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用状态图控制状态和逻辑"}},[_._v("#")]),_._v(" 使用状态图控制状态和逻辑")]),_._v(" "),t("p",[_._v("使用 hooks 封装代码最适合处理元素级的权限控制，但在面对需要根据多个维度的状态决定程序的状态或行为时，就有点力不从心了。而这，也是为什么有限状态机为什么有用的原因。")]),_._v(" "),t("h3",{attrs:{id:"结论"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结论"}},[_._v("#")]),_._v(" 结论")]),_._v(" "),t("p",[_._v("最终，我们选择了最灵活的 "),t("strong",[_._v("动态组件 + Hooks 共享逻辑")]),_._v(" 的形式，虽然使用动态组件会增加一些冗余度，但也可以通过子组件或 hooks 的形式复用逻辑，实际上在工程化减小的复杂度的收益是要高于代码冗余的。")]),_._v(" "),t("h2",{attrs:{id:"使用示例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用示例"}},[_._v("#")]),_._v(" 使用示例")]),_._v(" "),t("blockquote",[t("p",[_._v("登记相关内容已经使用该方式进行了重构")])]),_._v(" "),t("ul",[t("li",[t("code",[_._v("src/pages/register")]),_._v(" "),t("ul",[t("li",[t("code",[_._v("common")]),_._v(": 通用的一些组件和逻辑，例如请求后台接口应该是统一的，但返回的数据类型却应该是单独的\n"),t("ul",[t("li",[t("code",[_._v("form")]),_._v(": 表单相关组件，提供给列表/详情页面使用")]),_._v(" "),t("li",[t("code",[_._v("detail")]),_._v(": 详情页面")]),_._v(" "),t("li",[t("code",[_._v("list")]),_._v(": 列表页面")])])]),_._v(" "),t("li",[t("code",[_._v("organizations")]),_._v(": 不同组织的目录\n"),t("ul",[t("li",[t("code",[_._v("org1")]),_._v(": 组织 1")]),_._v(" "),t("li",[t("code",[_._v("org2")]),_._v(": 组织 2")])])])])])]),_._v(" "),t("p",[_._v("吾辈编写了一个简单的示例，代码在 "),t("a",{attrs:{href:"https://github.com/rxliuli/example/tree/master/dynamic_state",target:"_blank",rel:"noopener noreferrer"}},[_._v("dynamic_state"),t("OutboundLink")],1)]),_._v(" "),t("p",[t("img",{attrs:{src:"https://img.rxliuli.com/20200803203027.png",alt:"简单示例"}})]),_._v(" "),t("h2",{attrs:{id:"其他技术问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#其他技术问题"}},[_._v("#")]),_._v(" 其他技术问题")]),_._v(" "),t("ul",[t("li",[_._v("[x] 如何在运行时根据组织切换功能\n"),t("ul",[t("li",[_._v("可以再包一层组件而非简单的从 "),t("code",[_._v("lazy component map")]),_._v(" 取出组件")])])]),_._v(" "),t("li",[_._v("[x] 如何在运行时添加新组织的功能\n"),t("ul",[t("li",[_._v("可能需要插件的实现方式，支持动态加载进来，例如 vscode 的插件体系。")])])]),_._v(" "),t("li",[_._v("[x] 如何使用 hooks 更好的复用逻辑\n"),t("ul",[t("li",[_._v("使用 hooks 封装逻辑，使用小型组件封装 UI/UX")])])]),_._v(" "),t("li",[_._v("[x] 如何在打包阶段干掉不相关组织的代码\n"),t("ul",[t("li",[_._v("需要修改 webpack 相关的内容，目前不予考虑")])])])])])}),[],!1,null,null,null);v.default=r.exports}}]);