import{_ as n,M as i,p as l,q as r,R as s,t,N as p,a1 as a}from"./framework-96b046e1.js";const d="/assets/2779a9f352d849a6bb3c6fa91ca33c48-fcd942dc.svg",c={},o=a('<h2 id="场景" tabindex="-1"><a class="header-anchor" href="#场景" aria-hidden="true">#</a> 场景</h2><p>在我们使用 monorepo 将所有的前端项目放到一个项目中后，会面临各种各样的问题，其中的多个通用模块的初始化也会是一个问题。</p><p><img src="'+d+`" alt="monorepo 模块依赖图.drawio.svg"></p><p>下面是目前实践过的一些解决方案</p><ul><li>增量构建</li><li>捆绑依赖项</li><li>基于 esbuild</li><li>不构建 dts</li></ul><h2 id="增量构建" tabindex="-1"><a class="header-anchor" href="#增量构建" aria-hidden="true">#</a> 增量构建</h2><p>每次修改 libs 中的内容，其他人通过 git 拉取时都需要重新 <code>initialize</code>，如果知道在哪个包还好，可以仅运行指定包的 <code>initialize</code> 命令。如果不知道的话，则需要运行根目录的 <code>initialize</code> 命令，这其实是非常缓慢的，因为它会重新运行所有包含 <code>intialize</code> 命令的 npm 包，而不管它们是否有变更。</p><ol><li>减少 initialize 时间，提高协作的开发体验</li><li>支持 ci/cd 缓存已构建的 libs，加快构建时间</li></ol><p>需求</p><ul><li>尽可能地按照依赖图并发执行命令，并且基于 git 变更实现缓存</li><li>在指定模块依赖的模块执行命令</li><li>在所有子模块中执行命令</li></ul><p>真实项目构建时间</p><ul><li><code>lerna run</code><ul><li>新项目首次初始化 198.54s</li><li>非新项目再次初始化 90.17s</li></ul></li></ul><p>吾辈在 yarn-plugin-changed 模块中基于 yarn2 实现了这个功能。</p><h2 id="捆绑依赖项" tabindex="-1"><a class="header-anchor" href="#捆绑依赖项" aria-hidden="true">#</a> 捆绑依赖项</h2><p>加载一个文件总比加载 100 个小文件要快，这也是为什么 webpack 等工具会将开发的代码打包，yarn2 推动 pnp 的主要原因之一。对于 cli 而言，也是一样的道理，将依赖尽可能地打包到 bundle 中就好了。虽然打包本身会增加一点时间，但在其他模块使用 cli 时就会快一些。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>real    0m44.142s
user    0m0.122s
sys     0m0.214s
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>44.142s =&gt; 30s 438ms</p>`,17),u={href:"https://code.visualstudio.com/api/working-with-extensions/bundling-extension",target:"_blank",rel:"noopener noreferrer"},m=a(`<h2 id="基于-esbuild" tabindex="-1"><a class="header-anchor" href="#基于-esbuild" aria-hidden="true">#</a> 基于 esbuild</h2><p>rollup 使用 js 编写，它在使用必须的插件之后打包非常缓慢（可能部分要归结于 tsc 本身也非常慢），而 esbuild 在官方性能测试中要快 10-100 倍，这为性能优化提供了一种思路：将 CPU 密集型的功能使用高性能的语言构建。在使用 esbuild 命令行时，基本上，lib/cli 都能在数百毫秒内完成构建，而其中实际运行构建代码的时间大约只有几十毫秒，大部分时间是在等待 cli 启动。</p><p>下面是一个在单模块的性能测试</p><p>esbuild cli</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">time</span> esbuild src/bin.ts <span class="token parameter variable">--bundle</span> <span class="token parameter variable">--external:esbuild</span> --external:@yarnpkg/cli <span class="token parameter variable">--platform</span><span class="token operator">=</span>node <span class="token parameter variable">--outfile</span><span class="token operator">=</span>dist/bin.js <span class="token parameter variable">--sourcemap</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">\\</span>
<span class="token function">time</span> esbuild src/index.ts <span class="token parameter variable">--bundle</span> <span class="token parameter variable">--external:esbuild</span> --external:@yarnpkg/cli --external:fs-extra <span class="token parameter variable">--platform</span><span class="token operator">=</span>node <span class="token parameter variable">--format</span><span class="token operator">=</span>cjs <span class="token parameter variable">--outfile</span><span class="token operator">=</span>dist/index.js <span class="token parameter variable">--sourcemap</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">\\</span>
<span class="token function">time</span> esbuild src/index.ts <span class="token parameter variable">--bundle</span> <span class="token parameter variable">--external:esbuild</span> --external:@yarnpkg/cli --external:fs-extra <span class="token parameter variable">--platform</span><span class="token operator">=</span>node <span class="token parameter variable">--format</span><span class="token operator">=</span>esm <span class="token parameter variable">--outfile</span><span class="token operator">=</span>dist/index.esm.js <span class="token parameter variable">--sourcemap</span>
<span class="token comment"># 0m0.244s # 15ms</span>
<span class="token comment"># 0m0.211s # 4ms</span>
<span class="token comment"># 0m0.212s # 4ms</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>esbuild base nodejs cli</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">time</span> liuli-cli build cli <span class="token comment"># 0m2.276s # 1988ms</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="不构建-dts" tabindex="-1"><a class="header-anchor" href="#不构建-dts" aria-hidden="true">#</a> 不构建 dts</h2><p>为什么不构建 dts？</p><p>构建 dts 很慢，至于多慢呢？下面是一个构建 cli 的时间分析</p><p>不生成类型定义</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">time</span> <span class="token function">yarn</span> build
√ 构建 cli: 141ms
√ 构建 esm: 18ms
√ 构建 cjs: 17ms
构建完成: 142ms

real    0m4.000s
user    0m0.075s
sys     0m0.138s
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>生成类型定义</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">time</span> <span class="token function">yarn</span> build
√ 构建 cli: 3598ms
√ 构建 esm: 50ms
√ 构建 cjs: 3587ms
√ 生成类型定义: 3602ms
构建完成: 3614ms

real    0m7.763s
user    0m0.000s
sys     0m0.197s
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，生成类型定义耗费了大量的时间，与使用 esbuild 构建完全不在一个时间量级上。但同时，我们也必须注意到，nodejs 花费的真实时间很多，甚至远超构建本身，也就意味着，nodejs 确实存在性能极限。实际项目中，初始化 15 个模块需要 30s 438ms，而生成 dts 则需要 44s 343ms，单点优化对整体已经很难产生数量级的影响了。</p><p>问题</p><ul><li>通用模块中的 ts 的错误会蔓延到业务模块中，主要是在自定义 <code>src/@types/</code> 类型的时候</li></ul><h2 id="不做任何打包" tabindex="-1"><a class="header-anchor" href="#不做任何打包" aria-hidden="true">#</a> 不做任何打包</h2><p>虽然看起来不可思议，但在 monorepo 中，许多通用模块可能并不需要在 monorepo 之外使用到，所以对于有些不需要发布的模块，可以不做打包，而是直接在 package.json 中指向未打包的入口文件。</p><p>下面是一个 lib 的不打包配置</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;main&quot;</span><span class="token operator">:</span> <span class="token string">&quot;src/index.ts&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;module&quot;</span><span class="token operator">:</span> <span class="token string">&quot;src/index.ts&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;types&quot;</span><span class="token operator">:</span> <span class="token string">&quot;src/index.ts&quot;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，它也会带来一些副作用，例如</p><ul><li>使用该模块必须支持 ts</li><li>增加依赖该模块的终端程序的打包时间</li></ul>`,23);function v(b,h){const e=i("ExternalLinkIcon");return l(),r("div",null,[o,s("blockquote",null,[s("p",null,[s("a",u,[t("参考 VSCode 打包指南"),p(e)])])]),m])}const f=n(c,[["render",v],["__file","f35319c382cf488082a1df13dad35005.html.vue"]]);export{f as default};
